directive @withSubscription on OBJECT | INTERFACE

directive @secret(field: String!, pred: String) on OBJECT | INTERFACE

directive @remote on OBJECT | INTERFACE | UNION | INPUT_OBJECT | ENUM

directive @lambda on FIELD_DEFINITION

directive @hasInverse(field: String!) on FIELD_DEFINITION

directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION

directive @auth(password: AuthRule, query: AuthRule, add: AuthRule, update: AuthRule, delete: AuthRule) on OBJECT | INTERFACE

directive @generate(query: GenerateQueryParams, mutation: GenerateMutationParams, subscription: Boolean) on OBJECT | INTERFACE

directive @cascade(fields: [String]) on FIELD

directive @dgraph(type: String, pred: String) on OBJECT | INTERFACE | FIELD_DEFINITION

directive @id on FIELD_DEFINITION

directive @custom(http: CustomHTTP, dql: String) on FIELD_DEFINITION

directive @cacheControl(maxAge: Int!) on QUERY

type Account implements ReadOnly {
  _placeholder: String
  address: String!
  type: AccountType!
  stakes(filter: StakeFilter, order: StakeOrder, first: Int, offset: Int): [Stake!]!
  balances(filter: BalanceFilter, order: BalanceOrder, first: Int, offset: Int): [Balance!]!
  stakesAggregate(filter: StakeFilter): StakeAggregateResult
  balancesAggregate(filter: BalanceFilter): BalanceAggregateResult
}

type AccountAggregateResult {
  count: Int
  _placeholderMin: String
  _placeholderMax: String
  addressMin: String
  addressMax: String
}

input AccountFilter {
  address: StringHashFilter
  type: AccountType_hash
  has: AccountHasFilter
  and: [AccountFilter]
  or: [AccountFilter]
  not: AccountFilter
}

enum AccountHasFilter {
  _placeholder
  address
  type
  stakes
  balances
}

input AccountOrder {
  asc: AccountOrderable
  desc: AccountOrderable
  then: AccountOrder
}

enum AccountOrderable {
  _placeholder
  address
}

input AccountPatch {
  _placeholder: String
  type: AccountType
  stakes: [StakeRef!]
  balances: [BalanceRef!]
}

input AccountRef {
  _placeholder: String
  address: String
  type: AccountType
  stakes: [StakeRef!]
  balances: [BalanceRef!]
}

enum AccountType {
  User
  StakingContract
  TreasuryContract
}

input AccountType_hash {
  eq: AccountType
  in: [AccountType]
}

input AddAccountInput {
  _placeholder: String
  address: String!
  type: AccountType!
  stakes: [StakeRef!]!
  balances: [BalanceRef!]!
}

type AddAccountPayload {
  account(filter: AccountFilter, order: AccountOrder, first: Int, offset: Int): [Account]
  numUids: Int
}

input AddAppStateInput {
  _placeholder: String
  id: String!
  transactionIds: [String!]!
  totalStakingPower: Float!
  medianStakingPower: Float!
  maxStakingPower: Float!
}

type AddAppStatePayload {
  appState(filter: AppStateFilter, order: AppStateOrder, first: Int, offset: Int): [AppState]
  numUids: Int
}

input AddBalanceInput {
  _placeholder: String
  id: String!
  token: TokenRef!
  amount: Float!
  owner: AccountRef!
}

type AddBalancePayload {
  balance(filter: BalanceFilter, order: BalanceOrder, first: Int, offset: Int): [Balance]
  numUids: Int
}

input AddFooInput {
  id: String!
  value: Int!
}

type AddFooPayload {
  foo(filter: FooFilter, order: FooOrder, first: Int, offset: Int): [Foo]
  numUids: Int
}

input AddStakeInput {
  _placeholder: String
  id: String!
  token: TokenRef!
  amount: Float!
  committedStakingPeriod: Int!
  owner: AccountRef!
}

type AddStakePayload {
  stake(filter: StakeFilter, order: StakeOrder, first: Int, offset: Int): [Stake]
  numUids: Int
}

input AddTokenInput {
  _placeholder: String
  ticker: String!
  name: String!
  nav: Float!
  baseMultiplier: Float!
}

type AddTokenPayload {
  token(filter: TokenFilter, order: TokenOrder, first: Int, offset: Int): [Token]
  numUids: Int
}

input AddTransactionInput {
  _placeholder: String
  blockNumber: Int!
  timeStamp: DateTime!
  hash: String!
  nonce: Int!
  blockHash: String!
  from: String!
  contractAddress: String!
  to: String!
  value: String!
  tokenName: String!
  tokenSymbol: String!
  tokenDecimal: Int!
  transactionIndex: Int!
  gas: Int!
  gasPrice: String!
  gasUsed: Int!
  cumulativeGasUsed: Int!
  input: String!
  confirmations: Int!
}

type AddTransactionPayload {
  transaction(filter: TransactionFilter, order: TransactionOrder, first: Int, offset: Int): [Transaction]
  numUids: Int
}

type AppState implements Cuid & ReadOnly {
  _placeholder: String
  id: String!
  transactionIds: [String!]!
  totalStakingPower: Float!
  medianStakingPower: Float!
  maxStakingPower: Float!
}

type AppStateAggregateResult {
  count: Int
  _placeholderMin: String
  _placeholderMax: String
  idMin: String
  idMax: String
  totalStakingPowerMin: Float
  totalStakingPowerMax: Float
  totalStakingPowerSum: Float
  totalStakingPowerAvg: Float
  medianStakingPowerMin: Float
  medianStakingPowerMax: Float
  medianStakingPowerSum: Float
  medianStakingPowerAvg: Float
  maxStakingPowerMin: Float
  maxStakingPowerMax: Float
  maxStakingPowerSum: Float
  maxStakingPowerAvg: Float
}

input AppStateFilter {
  id: StringHashFilter
  transactionIds: StringHashFilter
  has: AppStateHasFilter
  and: [AppStateFilter]
  or: [AppStateFilter]
  not: AppStateFilter
}

enum AppStateHasFilter {
  _placeholder
  id
  transactionIds
  totalStakingPower
  medianStakingPower
  maxStakingPower
}

input AppStateOrder {
  asc: AppStateOrderable
  desc: AppStateOrderable
  then: AppStateOrder
}

enum AppStateOrderable {
  _placeholder
  id
  totalStakingPower
  medianStakingPower
  maxStakingPower
}

input AppStatePatch {
  _placeholder: String
  transactionIds: [String!]
  totalStakingPower: Float
  medianStakingPower: Float
  maxStakingPower: Float
}

input AppStateRef {
  _placeholder: String
  id: String
  transactionIds: [String!]
  totalStakingPower: Float
  medianStakingPower: Float
  maxStakingPower: Float
}

input AuthRule {
  and: [AuthRule]
  or: [AuthRule]
  not: AuthRule
  rule: String
}

type Balance implements Cuid & ReadOnly {
  _placeholder: String
  id: String!
  token(filter: TokenFilter): Token!
  amount: Float!
  owner(filter: AccountFilter): Account!
}

type BalanceAggregateResult {
  count: Int
  _placeholderMin: String
  _placeholderMax: String
  idMin: String
  idMax: String
  amountMin: Float
  amountMax: Float
  amountSum: Float
  amountAvg: Float
}

input BalanceFilter {
  id: StringHashFilter
  has: BalanceHasFilter
  and: [BalanceFilter]
  or: [BalanceFilter]
  not: BalanceFilter
}

enum BalanceHasFilter {
  _placeholder
  id
  token
  amount
  owner
}

input BalanceOrder {
  asc: BalanceOrderable
  desc: BalanceOrderable
  then: BalanceOrder
}

enum BalanceOrderable {
  _placeholder
  id
  amount
}

input BalancePatch {
  _placeholder: String
  token: TokenRef
  amount: Float
  owner: AccountRef
}

input BalanceRef {
  _placeholder: String
  id: String
  token: TokenRef
  amount: Float
  owner: AccountRef
}

input ContainsFilter {
  point: PointRef
  polygon: PolygonRef
}

interface Cuid {
  id: String!
}

type CuidAggregateResult {
  count: Int
  idMin: String
  idMax: String
}

input CuidFilter {
  id: StringHashFilter
  has: CuidHasFilter
  and: [CuidFilter]
  or: [CuidFilter]
  not: CuidFilter
}

enum CuidHasFilter {
  id
}

input CuidOrder {
  asc: CuidOrderable
  desc: CuidOrderable
  then: CuidOrder
}

enum CuidOrderable {
  id
}

input CuidRef {
  id: String!
}

input CustomHTTP {
  url: String!
  method: HTTPMethod!
  body: String
  graphql: String
  mode: Mode
  forwardHeaders: [String!]
  secretHeaders: [String!]
  introspectionHeaders: [String!]
  skipIntrospection: Boolean
}

"""
The DateTime scalar type represents date and time as a string in RFC3339 format.
For example: "1985-04-12T23:20:50.52Z" represents 20 minutes and 50.52 seconds
after the 23rd hour of April 12th, 1985 in UTC.
"""
scalar DateTime

input DateTimeFilter {
  eq: DateTime
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
  between: DateTimeRange
}

input DateTimeRange {
  min: DateTime!
  max: DateTime!
}

type DeleteAccountPayload {
  account(filter: AccountFilter, order: AccountOrder, first: Int, offset: Int): [Account]
  msg: String
  numUids: Int
}

type DeleteAppStatePayload {
  appState(filter: AppStateFilter, order: AppStateOrder, first: Int, offset: Int): [AppState]
  msg: String
  numUids: Int
}

type DeleteBalancePayload {
  balance(filter: BalanceFilter, order: BalanceOrder, first: Int, offset: Int): [Balance]
  msg: String
  numUids: Int
}

type DeleteCuidPayload {
  cuid(filter: CuidFilter, order: CuidOrder, first: Int, offset: Int): [Cuid]
  msg: String
  numUids: Int
}

type DeleteFooPayload {
  foo(filter: FooFilter, order: FooOrder, first: Int, offset: Int): [Foo]
  msg: String
  numUids: Int
}

type DeleteReadOnlyPayload {
  readOnly(filter: ReadOnlyFilter, order: ReadOnlyOrder, first: Int, offset: Int): [ReadOnly]
  msg: String
  numUids: Int
}

type DeleteStakePayload {
  stake(filter: StakeFilter, order: StakeOrder, first: Int, offset: Int): [Stake]
  msg: String
  numUids: Int
}

type DeleteTokenPayload {
  token(filter: TokenFilter, order: TokenOrder, first: Int, offset: Int): [Token]
  msg: String
  numUids: Int
}

type DeleteTransactionPayload {
  transaction(filter: TransactionFilter, order: TransactionOrder, first: Int, offset: Int): [Transaction]
  msg: String
  numUids: Int
}

enum DgraphIndex {
  int
  int64
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
  geo
}

input FloatFilter {
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: FloatRange
}

input FloatRange {
  min: Float!
  max: Float!
}

type Foo {
  id: String!
  value: Int!
}

type FooAggregateResult {
  count: Int
  idMin: String
  idMax: String
  valueMin: Int
  valueMax: Int
  valueSum: Int
  valueAvg: Float
}

input FooFilter {
  id: StringHashFilter
  has: FooHasFilter
  and: [FooFilter]
  or: [FooFilter]
  not: FooFilter
}

enum FooHasFilter {
  id
  value
}

input FooOrder {
  asc: FooOrderable
  desc: FooOrderable
  then: FooOrder
}

enum FooOrderable {
  id
  value
}

input FooPatch {
  value: Int
}

input FooRef {
  id: String
  value: Int
}

input GenerateMutationParams {
  add: Boolean
  update: Boolean
  delete: Boolean
}

input GenerateQueryParams {
  get: Boolean
  query: Boolean
  password: Boolean
  aggregate: Boolean
}

enum HTTPMethod {
  GET
  POST
  PUT
  PATCH
  DELETE
}

"""
The Int64 scalar type represents a signed 64‐bit numeric non‐fractional value.
Int64 can represent values in range [-(2^63),(2^63 - 1)].
"""
scalar Int64

input Int64Filter {
  eq: Int64
  le: Int64
  lt: Int64
  ge: Int64
  gt: Int64
  between: Int64Range
}

input Int64Range {
  min: Int64!
  max: Int64!
}

input IntersectsFilter {
  polygon: PolygonRef
  multiPolygon: MultiPolygonRef
}

input IntFilter {
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: IntRange
}

input IntRange {
  min: Int!
  max: Int!
}

enum Mode {
  BATCH
  SINGLE
}

type MultiPolygon {
  polygons: [Polygon!]!
}

input MultiPolygonRef {
  polygons: [PolygonRef!]!
}

type Mutation {
  addFoo(input: [AddFooInput!]!): AddFooPayload
  updateFoo(input: UpdateFooInput!): UpdateFooPayload
  deleteFoo(filter: FooFilter!): DeleteFooPayload
  updateReadOnly(input: UpdateReadOnlyInput!): UpdateReadOnlyPayload
  deleteReadOnly(filter: ReadOnlyFilter!): DeleteReadOnlyPayload
  deleteCuid(filter: CuidFilter!): DeleteCuidPayload
  addToken(input: [AddTokenInput!]!): AddTokenPayload
  updateToken(input: UpdateTokenInput!): UpdateTokenPayload
  deleteToken(filter: TokenFilter!): DeleteTokenPayload
  addStake(input: [AddStakeInput!]!): AddStakePayload
  updateStake(input: UpdateStakeInput!): UpdateStakePayload
  deleteStake(filter: StakeFilter!): DeleteStakePayload
  addBalance(input: [AddBalanceInput!]!): AddBalancePayload
  updateBalance(input: UpdateBalanceInput!): UpdateBalancePayload
  deleteBalance(filter: BalanceFilter!): DeleteBalancePayload
  addAccount(input: [AddAccountInput!]!): AddAccountPayload
  updateAccount(input: UpdateAccountInput!): UpdateAccountPayload
  deleteAccount(filter: AccountFilter!): DeleteAccountPayload
  addTransaction(input: [AddTransactionInput!]!): AddTransactionPayload
  updateTransaction(input: UpdateTransactionInput!): UpdateTransactionPayload
  deleteTransaction(filter: TransactionFilter!): DeleteTransactionPayload
  addAppState(input: [AddAppStateInput!]!): AddAppStatePayload
  updateAppState(input: UpdateAppStateInput!): UpdateAppStatePayload
  deleteAppState(filter: AppStateFilter!): DeleteAppStatePayload
}

input NearFilter {
  distance: Float!
  coordinate: PointRef!
}

type Point {
  longitude: Float!
  latitude: Float!
}

input PointGeoFilter {
  near: NearFilter
  within: WithinFilter
}

type PointList {
  points: [Point!]!
}

input PointListRef {
  points: [PointRef!]!
}

input PointRef {
  longitude: Float!
  latitude: Float!
}

type Polygon {
  coordinates: [PointList!]!
}

input PolygonGeoFilter {
  near: NearFilter
  within: WithinFilter
  contains: ContainsFilter
  intersects: IntersectsFilter
}

input PolygonRef {
  coordinates: [PointListRef!]!
}

type Query {
  getFoo(id: String!): Foo
  queryFoo(filter: FooFilter, order: FooOrder, first: Int, offset: Int): [Foo]
  aggregateFoo(filter: FooFilter): FooAggregateResult
  queryReadOnly(filter: ReadOnlyFilter, order: ReadOnlyOrder, first: Int, offset: Int): [ReadOnly]
  aggregateReadOnly(filter: ReadOnlyFilter): ReadOnlyAggregateResult
  getCuid(id: String!): Cuid
  queryCuid(filter: CuidFilter, order: CuidOrder, first: Int, offset: Int): [Cuid]
  aggregateCuid(filter: CuidFilter): CuidAggregateResult
  getToken(ticker: String!): Token
  queryToken(filter: TokenFilter, order: TokenOrder, first: Int, offset: Int): [Token]
  aggregateToken(filter: TokenFilter): TokenAggregateResult
  getStake(id: String!): Stake
  queryStake(filter: StakeFilter, order: StakeOrder, first: Int, offset: Int): [Stake]
  aggregateStake(filter: StakeFilter): StakeAggregateResult
  getBalance(id: String!): Balance
  queryBalance(filter: BalanceFilter, order: BalanceOrder, first: Int, offset: Int): [Balance]
  aggregateBalance(filter: BalanceFilter): BalanceAggregateResult
  getAccount(address: String!): Account
  queryAccount(filter: AccountFilter, order: AccountOrder, first: Int, offset: Int): [Account]
  aggregateAccount(filter: AccountFilter): AccountAggregateResult
  getTransaction(hash: String!): Transaction
  queryTransaction(filter: TransactionFilter, order: TransactionOrder, first: Int, offset: Int): [Transaction]
  aggregateTransaction(filter: TransactionFilter): TransactionAggregateResult
  getAppState(id: String!): AppState
  queryAppState(filter: AppStateFilter, order: AppStateOrder, first: Int, offset: Int): [AppState]
  aggregateAppState(filter: AppStateFilter): AppStateAggregateResult
}

interface ReadOnly {
  _placeholder: String
}

type ReadOnlyAggregateResult {
  count: Int
  _placeholderMin: String
  _placeholderMax: String
}

input ReadOnlyFilter {
  has: ReadOnlyHasFilter
  and: [ReadOnlyFilter]
  or: [ReadOnlyFilter]
  not: ReadOnlyFilter
}

enum ReadOnlyHasFilter {
  _placeholder
}

input ReadOnlyOrder {
  asc: ReadOnlyOrderable
  desc: ReadOnlyOrderable
  then: ReadOnlyOrder
}

enum ReadOnlyOrderable {
  _placeholder
}

input ReadOnlyPatch {
  _placeholder: String
}

enum Role {
  ADMIN
  USER
}

type Stake implements Cuid & ReadOnly {
  _placeholder: String
  id: String!
  token(filter: TokenFilter): Token!
  amount: Float!
  committedStakingPeriod: Int!
  owner(filter: AccountFilter): Account!
}

type StakeAggregateResult {
  count: Int
  _placeholderMin: String
  _placeholderMax: String
  idMin: String
  idMax: String
  amountMin: Float
  amountMax: Float
  amountSum: Float
  amountAvg: Float
  committedStakingPeriodMin: Int
  committedStakingPeriodMax: Int
  committedStakingPeriodSum: Int
  committedStakingPeriodAvg: Float
}

input StakeFilter {
  id: StringHashFilter
  has: StakeHasFilter
  and: [StakeFilter]
  or: [StakeFilter]
  not: StakeFilter
}

enum StakeHasFilter {
  _placeholder
  id
  token
  amount
  committedStakingPeriod
  owner
}

input StakeOrder {
  asc: StakeOrderable
  desc: StakeOrderable
  then: StakeOrder
}

enum StakeOrderable {
  _placeholder
  id
  amount
  committedStakingPeriod
}

input StakePatch {
  _placeholder: String
  token: TokenRef
  amount: Float
  committedStakingPeriod: Int
  owner: AccountRef
}

input StakeRef {
  _placeholder: String
  id: String
  token: TokenRef
  amount: Float
  committedStakingPeriod: Int
  owner: AccountRef
}

input StringExactFilter {
  eq: String
  in: [String]
  le: String
  lt: String
  ge: String
  gt: String
  between: StringRange
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringHashFilter {
  eq: String
  in: [String]
}

input StringRange {
  min: String!
  max: String!
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

type Subscription {
  getToken(ticker: String!): Token
  queryToken(filter: TokenFilter, order: TokenOrder, first: Int, offset: Int): [Token]
  aggregateToken(filter: TokenFilter): TokenAggregateResult
  getAccount(address: String!): Account
  queryAccount(filter: AccountFilter, order: AccountOrder, first: Int, offset: Int): [Account]
  aggregateAccount(filter: AccountFilter): AccountAggregateResult
}

type Token implements ReadOnly {
  _placeholder: String
  ticker: String!
  name: String!
  nav: Float!
  baseMultiplier: Float!
}

type TokenAggregateResult {
  count: Int
  _placeholderMin: String
  _placeholderMax: String
  tickerMin: String
  tickerMax: String
  nameMin: String
  nameMax: String
  navMin: Float
  navMax: Float
  navSum: Float
  navAvg: Float
  baseMultiplierMin: Float
  baseMultiplierMax: Float
  baseMultiplierSum: Float
  baseMultiplierAvg: Float
}

input TokenFilter {
  ticker: StringHashFilter
  has: TokenHasFilter
  and: [TokenFilter]
  or: [TokenFilter]
  not: TokenFilter
}

enum TokenHasFilter {
  _placeholder
  ticker
  name
  nav
  baseMultiplier
}

input TokenOrder {
  asc: TokenOrderable
  desc: TokenOrderable
  then: TokenOrder
}

enum TokenOrderable {
  _placeholder
  ticker
  name
  nav
  baseMultiplier
}

input TokenPatch {
  _placeholder: String
  name: String
  nav: Float
  baseMultiplier: Float
}

input TokenRef {
  _placeholder: String
  ticker: String
  name: String
  nav: Float
  baseMultiplier: Float
}

type Transaction implements ReadOnly {
  _placeholder: String
  blockNumber: Int!
  timeStamp: DateTime!
  hash: String!
  nonce: Int!
  blockHash: String!
  from: String!
  contractAddress: String!
  to: String!
  value: String!
  tokenName: String!
  tokenSymbol: String!
  tokenDecimal: Int!
  transactionIndex: Int!
  gas: Int!
  gasPrice: String!
  gasUsed: Int!
  cumulativeGasUsed: Int!
  input: String!
  confirmations: Int!
}

type TransactionAggregateResult {
  count: Int
  _placeholderMin: String
  _placeholderMax: String
  blockNumberMin: Int
  blockNumberMax: Int
  blockNumberSum: Int
  blockNumberAvg: Float
  timeStampMin: DateTime
  timeStampMax: DateTime
  hashMin: String
  hashMax: String
  nonceMin: Int
  nonceMax: Int
  nonceSum: Int
  nonceAvg: Float
  blockHashMin: String
  blockHashMax: String
  fromMin: String
  fromMax: String
  contractAddressMin: String
  contractAddressMax: String
  toMin: String
  toMax: String
  valueMin: String
  valueMax: String
  tokenNameMin: String
  tokenNameMax: String
  tokenSymbolMin: String
  tokenSymbolMax: String
  tokenDecimalMin: Int
  tokenDecimalMax: Int
  tokenDecimalSum: Int
  tokenDecimalAvg: Float
  transactionIndexMin: Int
  transactionIndexMax: Int
  transactionIndexSum: Int
  transactionIndexAvg: Float
  gasMin: Int
  gasMax: Int
  gasSum: Int
  gasAvg: Float
  gasPriceMin: String
  gasPriceMax: String
  gasUsedMin: Int
  gasUsedMax: Int
  gasUsedSum: Int
  gasUsedAvg: Float
  cumulativeGasUsedMin: Int
  cumulativeGasUsedMax: Int
  cumulativeGasUsedSum: Int
  cumulativeGasUsedAvg: Float
  inputMin: String
  inputMax: String
  confirmationsMin: Int
  confirmationsMax: Int
  confirmationsSum: Int
  confirmationsAvg: Float
}

input TransactionFilter {
  hash: StringHashFilter
  has: TransactionHasFilter
  and: [TransactionFilter]
  or: [TransactionFilter]
  not: TransactionFilter
}

enum TransactionHasFilter {
  _placeholder
  blockNumber
  timeStamp
  hash
  nonce
  blockHash
  from
  contractAddress
  to
  value
  tokenName
  tokenSymbol
  tokenDecimal
  transactionIndex
  gas
  gasPrice
  gasUsed
  cumulativeGasUsed
  input
  confirmations
}

input TransactionOrder {
  asc: TransactionOrderable
  desc: TransactionOrderable
  then: TransactionOrder
}

enum TransactionOrderable {
  _placeholder
  blockNumber
  timeStamp
  hash
  nonce
  blockHash
  from
  contractAddress
  to
  value
  tokenName
  tokenSymbol
  tokenDecimal
  transactionIndex
  gas
  gasPrice
  gasUsed
  cumulativeGasUsed
  input
  confirmations
}

input TransactionPatch {
  _placeholder: String
  blockNumber: Int
  timeStamp: DateTime
  nonce: Int
  blockHash: String
  from: String
  contractAddress: String
  to: String
  value: String
  tokenName: String
  tokenSymbol: String
  tokenDecimal: Int
  transactionIndex: Int
  gas: Int
  gasPrice: String
  gasUsed: Int
  cumulativeGasUsed: Int
  input: String
  confirmations: Int
}

input TransactionRef {
  _placeholder: String
  blockNumber: Int
  timeStamp: DateTime
  hash: String
  nonce: Int
  blockHash: String
  from: String
  contractAddress: String
  to: String
  value: String
  tokenName: String
  tokenSymbol: String
  tokenDecimal: Int
  transactionIndex: Int
  gas: Int
  gasPrice: String
  gasUsed: Int
  cumulativeGasUsed: Int
  input: String
  confirmations: Int
}

input UpdateAccountInput {
  filter: AccountFilter!
  set: AccountPatch
  remove: AccountPatch
}

type UpdateAccountPayload {
  account(filter: AccountFilter, order: AccountOrder, first: Int, offset: Int): [Account]
  numUids: Int
}

input UpdateAppStateInput {
  filter: AppStateFilter!
  set: AppStatePatch
  remove: AppStatePatch
}

type UpdateAppStatePayload {
  appState(filter: AppStateFilter, order: AppStateOrder, first: Int, offset: Int): [AppState]
  numUids: Int
}

input UpdateBalanceInput {
  filter: BalanceFilter!
  set: BalancePatch
  remove: BalancePatch
}

type UpdateBalancePayload {
  balance(filter: BalanceFilter, order: BalanceOrder, first: Int, offset: Int): [Balance]
  numUids: Int
}

input UpdateFooInput {
  filter: FooFilter!
  set: FooPatch
  remove: FooPatch
}

type UpdateFooPayload {
  foo(filter: FooFilter, order: FooOrder, first: Int, offset: Int): [Foo]
  numUids: Int
}

input UpdateReadOnlyInput {
  filter: ReadOnlyFilter!
  set: ReadOnlyPatch
  remove: ReadOnlyPatch
}

type UpdateReadOnlyPayload {
  readOnly(filter: ReadOnlyFilter, order: ReadOnlyOrder, first: Int, offset: Int): [ReadOnly]
  numUids: Int
}

input UpdateStakeInput {
  filter: StakeFilter!
  set: StakePatch
  remove: StakePatch
}

type UpdateStakePayload {
  stake(filter: StakeFilter, order: StakeOrder, first: Int, offset: Int): [Stake]
  numUids: Int
}

input UpdateTokenInput {
  filter: TokenFilter!
  set: TokenPatch
  remove: TokenPatch
}

type UpdateTokenPayload {
  token(filter: TokenFilter, order: TokenOrder, first: Int, offset: Int): [Token]
  numUids: Int
}

input UpdateTransactionInput {
  filter: TransactionFilter!
  set: TransactionPatch
  remove: TransactionPatch
}

type UpdateTransactionPayload {
  transaction(filter: TransactionFilter, order: TransactionOrder, first: Int, offset: Int): [Transaction]
  numUids: Int
}

input WithinFilter {
  polygon: PolygonRef!
}

