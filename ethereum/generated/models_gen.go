// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package invictusicap

import (
	"fmt"
	"io"
	"strconv"
)

type Cuid interface {
	IsCuid()
}

type ReadOnly interface {
	IsReadOnly()
}

type Account struct {
	Placeholder       *string                 `json:"_placeholder"`
	Address           string                  `json:"address"`
	Type              AccountType             `json:"type"`
	Stakes            []*Stake                `json:"stakes"`
	Balances          []*Balance              `json:"balances"`
	StakesAggregate   *StakeAggregateResult   `json:"stakesAggregate"`
	BalancesAggregate *BalanceAggregateResult `json:"balancesAggregate"`
}

func (Account) IsReadOnly() {}

type AccountAggregateResult struct {
	Count          *int    `json:"count"`
	PlaceholderMin *string `json:"_placeholderMin"`
	PlaceholderMax *string `json:"_placeholderMax"`
	AddressMin     *string `json:"addressMin"`
	AddressMax     *string `json:"addressMax"`
}

type AccountFilter struct {
	Address *StringHashFilter `json:"address"`
	Type    *AccountTypeHash  `json:"type"`
	Has     *AccountHasFilter `json:"has"`
	And     []*AccountFilter  `json:"and"`
	Or      []*AccountFilter  `json:"or"`
	Not     *AccountFilter    `json:"not"`
}

type AccountOrder struct {
	Asc  *AccountOrderable `json:"asc"`
	Desc *AccountOrderable `json:"desc"`
	Then *AccountOrder     `json:"then"`
}

type AccountPatch struct {
	Placeholder *string       `json:"_placeholder"`
	Type        *AccountType  `json:"type"`
	Stakes      []*StakeRef   `json:"stakes"`
	Balances    []*BalanceRef `json:"balances"`
}

type AccountRef struct {
	Placeholder *string       `json:"_placeholder"`
	Address     *string       `json:"address"`
	Type        *AccountType  `json:"type"`
	Stakes      []*StakeRef   `json:"stakes"`
	Balances    []*BalanceRef `json:"balances"`
}

type AccountTypeHash struct {
	Eq *AccountType   `json:"eq"`
	In []*AccountType `json:"in"`
}

type AddAccountInput struct {
	Placeholder *string       `json:"_placeholder"`
	Address     string        `json:"address"`
	Type        AccountType   `json:"type"`
	Stakes      []*StakeRef   `json:"stakes"`
	Balances    []*BalanceRef `json:"balances"`
}

type AddAccountPayload struct {
	Account []*Account `json:"account"`
	NumUids *int       `json:"numUids"`
}

type AddAppStateInput struct {
	Placeholder        *string  `json:"_placeholder"`
	ID                 string   `json:"id"`
	TransactionIds     []string `json:"transactionIds"`
	TotalStakingPower  float64  `json:"totalStakingPower"`
	MedianStakingPower float64  `json:"medianStakingPower"`
	MaxStakingPower    float64  `json:"maxStakingPower"`
	EthPrice           float64  `json:"ethPrice"`
}

type AddAppStatePayload struct {
	AppState []*AppState `json:"appState"`
	NumUids  *int        `json:"numUids"`
}

type AddBalanceInput struct {
	Placeholder *string     `json:"_placeholder"`
	ID          string      `json:"id"`
	Token       *TokenRef   `json:"token"`
	Amount      float64     `json:"amount"`
	Owner       *AccountRef `json:"owner"`
}

type AddBalancePayload struct {
	Balance []*Balance `json:"balance"`
	NumUids *int       `json:"numUids"`
}

type AddFooInput struct {
	ID    string `json:"id"`
	Value int    `json:"value"`
}

type AddFooPayload struct {
	Foo     []*Foo `json:"foo"`
	NumUids *int   `json:"numUids"`
}

type AddStakeInput struct {
	Placeholder            *string     `json:"_placeholder"`
	ID                     string      `json:"id"`
	Token                  *TokenRef   `json:"token"`
	Amount                 float64     `json:"amount"`
	CommittedStakingPeriod int         `json:"committedStakingPeriod"`
	Owner                  *AccountRef `json:"owner"`
}

type AddStakePayload struct {
	Stake   []*Stake `json:"stake"`
	NumUids *int     `json:"numUids"`
}

type AddTokenInput struct {
	Placeholder    *string `json:"_placeholder"`
	Ticker         string  `json:"ticker"`
	Name           string  `json:"name"`
	Nav            float64 `json:"nav"`
	BaseMultiplier float64 `json:"baseMultiplier"`
}

type AddTokenPayload struct {
	Token   []*Token `json:"token"`
	NumUids *int     `json:"numUids"`
}

type AddTransactionInput struct {
	Placeholder       *string `json:"_placeholder"`
	BlockNumber       int     `json:"blockNumber"`
	TimeStamp         string  `json:"timeStamp"`
	Hash              string  `json:"hash"`
	Nonce             int     `json:"nonce"`
	BlockHash         string  `json:"blockHash"`
	From              string  `json:"from"`
	ContractAddress   string  `json:"contractAddress"`
	To                string  `json:"to"`
	Value             string  `json:"value"`
	TokenName         string  `json:"tokenName"`
	TokenSymbol       string  `json:"tokenSymbol"`
	TokenDecimal      int     `json:"tokenDecimal"`
	TransactionIndex  int     `json:"transactionIndex"`
	Gas               int     `json:"gas"`
	GasPrice          string  `json:"gasPrice"`
	GasUsed           int     `json:"gasUsed"`
	CumulativeGasUsed int     `json:"cumulativeGasUsed"`
	Input             string  `json:"input"`
	Confirmations     int     `json:"confirmations"`
}

type AddTransactionPayload struct {
	Transaction []*Transaction `json:"transaction"`
	NumUids     *int           `json:"numUids"`
}

type AppState struct {
	Placeholder        *string  `json:"_placeholder"`
	ID                 string   `json:"id"`
	TransactionIds     []string `json:"transactionIds"`
	TotalStakingPower  float64  `json:"totalStakingPower"`
	MedianStakingPower float64  `json:"medianStakingPower"`
	MaxStakingPower    float64  `json:"maxStakingPower"`
	EthPrice           float64  `json:"ethPrice"`
}

func (AppState) IsCuid()     {}
func (AppState) IsReadOnly() {}

type AppStateAggregateResult struct {
	Count                 *int     `json:"count"`
	PlaceholderMin        *string  `json:"_placeholderMin"`
	PlaceholderMax        *string  `json:"_placeholderMax"`
	IDMin                 *string  `json:"idMin"`
	IDMax                 *string  `json:"idMax"`
	TotalStakingPowerMin  *float64 `json:"totalStakingPowerMin"`
	TotalStakingPowerMax  *float64 `json:"totalStakingPowerMax"`
	TotalStakingPowerSum  *float64 `json:"totalStakingPowerSum"`
	TotalStakingPowerAvg  *float64 `json:"totalStakingPowerAvg"`
	MedianStakingPowerMin *float64 `json:"medianStakingPowerMin"`
	MedianStakingPowerMax *float64 `json:"medianStakingPowerMax"`
	MedianStakingPowerSum *float64 `json:"medianStakingPowerSum"`
	MedianStakingPowerAvg *float64 `json:"medianStakingPowerAvg"`
	MaxStakingPowerMin    *float64 `json:"maxStakingPowerMin"`
	MaxStakingPowerMax    *float64 `json:"maxStakingPowerMax"`
	MaxStakingPowerSum    *float64 `json:"maxStakingPowerSum"`
	MaxStakingPowerAvg    *float64 `json:"maxStakingPowerAvg"`
	EthPriceMin           *float64 `json:"ethPriceMin"`
	EthPriceMax           *float64 `json:"ethPriceMax"`
	EthPriceSum           *float64 `json:"ethPriceSum"`
	EthPriceAvg           *float64 `json:"ethPriceAvg"`
}

type AppStateFilter struct {
	ID             *StringHashFilter  `json:"id"`
	TransactionIds *StringHashFilter  `json:"transactionIds"`
	Has            *AppStateHasFilter `json:"has"`
	And            []*AppStateFilter  `json:"and"`
	Or             []*AppStateFilter  `json:"or"`
	Not            *AppStateFilter    `json:"not"`
}

type AppStateOrder struct {
	Asc  *AppStateOrderable `json:"asc"`
	Desc *AppStateOrderable `json:"desc"`
	Then *AppStateOrder     `json:"then"`
}

type AppStatePatch struct {
	Placeholder        *string  `json:"_placeholder"`
	TransactionIds     []string `json:"transactionIds"`
	TotalStakingPower  *float64 `json:"totalStakingPower"`
	MedianStakingPower *float64 `json:"medianStakingPower"`
	MaxStakingPower    *float64 `json:"maxStakingPower"`
	EthPrice           *float64 `json:"ethPrice"`
}

type AppStateRef struct {
	Placeholder        *string  `json:"_placeholder"`
	ID                 *string  `json:"id"`
	TransactionIds     []string `json:"transactionIds"`
	TotalStakingPower  *float64 `json:"totalStakingPower"`
	MedianStakingPower *float64 `json:"medianStakingPower"`
	MaxStakingPower    *float64 `json:"maxStakingPower"`
	EthPrice           *float64 `json:"ethPrice"`
}

type AuthRule struct {
	And  []*AuthRule `json:"and"`
	Or   []*AuthRule `json:"or"`
	Not  *AuthRule   `json:"not"`
	Rule *string     `json:"rule"`
}

type Balance struct {
	Placeholder *string  `json:"_placeholder"`
	ID          string   `json:"id"`
	Token       *Token   `json:"token"`
	Amount      float64  `json:"amount"`
	Owner       *Account `json:"owner"`
}

func (Balance) IsCuid()     {}
func (Balance) IsReadOnly() {}

type BalanceAggregateResult struct {
	Count          *int     `json:"count"`
	PlaceholderMin *string  `json:"_placeholderMin"`
	PlaceholderMax *string  `json:"_placeholderMax"`
	IDMin          *string  `json:"idMin"`
	IDMax          *string  `json:"idMax"`
	AmountMin      *float64 `json:"amountMin"`
	AmountMax      *float64 `json:"amountMax"`
	AmountSum      *float64 `json:"amountSum"`
	AmountAvg      *float64 `json:"amountAvg"`
}

type BalanceFilter struct {
	ID  *StringHashFilter `json:"id"`
	Has *BalanceHasFilter `json:"has"`
	And []*BalanceFilter  `json:"and"`
	Or  []*BalanceFilter  `json:"or"`
	Not *BalanceFilter    `json:"not"`
}

type BalanceOrder struct {
	Asc  *BalanceOrderable `json:"asc"`
	Desc *BalanceOrderable `json:"desc"`
	Then *BalanceOrder     `json:"then"`
}

type BalancePatch struct {
	Placeholder *string     `json:"_placeholder"`
	Token       *TokenRef   `json:"token"`
	Amount      *float64    `json:"amount"`
	Owner       *AccountRef `json:"owner"`
}

type BalanceRef struct {
	Placeholder *string     `json:"_placeholder"`
	ID          *string     `json:"id"`
	Token       *TokenRef   `json:"token"`
	Amount      *float64    `json:"amount"`
	Owner       *AccountRef `json:"owner"`
}

type ContainsFilter struct {
	Point   *PointRef   `json:"point"`
	Polygon *PolygonRef `json:"polygon"`
}

type CuidAggregateResult struct {
	Count *int    `json:"count"`
	IDMin *string `json:"idMin"`
	IDMax *string `json:"idMax"`
}

type CuidFilter struct {
	ID  *StringHashFilter `json:"id"`
	Has *CuidHasFilter    `json:"has"`
	And []*CuidFilter     `json:"and"`
	Or  []*CuidFilter     `json:"or"`
	Not *CuidFilter       `json:"not"`
}

type CuidOrder struct {
	Asc  *CuidOrderable `json:"asc"`
	Desc *CuidOrderable `json:"desc"`
	Then *CuidOrder     `json:"then"`
}

type CuidRef struct {
	ID string `json:"id"`
}

type CustomHTTP struct {
	URL                  string     `json:"url"`
	Method               HTTPMethod `json:"method"`
	Body                 *string    `json:"body"`
	Graphql              *string    `json:"graphql"`
	Mode                 *Mode      `json:"mode"`
	ForwardHeaders       []string   `json:"forwardHeaders"`
	SecretHeaders        []string   `json:"secretHeaders"`
	IntrospectionHeaders []string   `json:"introspectionHeaders"`
	SkipIntrospection    *bool      `json:"skipIntrospection"`
}

type DateTimeFilter struct {
	Eq      *string        `json:"eq"`
	Le      *string        `json:"le"`
	Lt      *string        `json:"lt"`
	Ge      *string        `json:"ge"`
	Gt      *string        `json:"gt"`
	Between *DateTimeRange `json:"between"`
}

type DateTimeRange struct {
	Min string `json:"min"`
	Max string `json:"max"`
}

type DeleteAccountPayload struct {
	Account []*Account `json:"account"`
	Msg     *string    `json:"msg"`
	NumUids *int       `json:"numUids"`
}

type DeleteAppStatePayload struct {
	AppState []*AppState `json:"appState"`
	Msg      *string     `json:"msg"`
	NumUids  *int        `json:"numUids"`
}

type DeleteBalancePayload struct {
	Balance []*Balance `json:"balance"`
	Msg     *string    `json:"msg"`
	NumUids *int       `json:"numUids"`
}

type DeleteCuidPayload struct {
	Cuid    []Cuid  `json:"cuid"`
	Msg     *string `json:"msg"`
	NumUids *int    `json:"numUids"`
}

type DeleteFooPayload struct {
	Foo     []*Foo  `json:"foo"`
	Msg     *string `json:"msg"`
	NumUids *int    `json:"numUids"`
}

type DeleteReadOnlyPayload struct {
	ReadOnly []ReadOnly `json:"readOnly"`
	Msg      *string    `json:"msg"`
	NumUids  *int       `json:"numUids"`
}

type DeleteStakePayload struct {
	Stake   []*Stake `json:"stake"`
	Msg     *string  `json:"msg"`
	NumUids *int     `json:"numUids"`
}

type DeleteTokenPayload struct {
	Token   []*Token `json:"token"`
	Msg     *string  `json:"msg"`
	NumUids *int     `json:"numUids"`
}

type DeleteTransactionPayload struct {
	Transaction []*Transaction `json:"transaction"`
	Msg         *string        `json:"msg"`
	NumUids     *int           `json:"numUids"`
}

type FloatFilter struct {
	Eq      *float64    `json:"eq"`
	Le      *float64    `json:"le"`
	Lt      *float64    `json:"lt"`
	Ge      *float64    `json:"ge"`
	Gt      *float64    `json:"gt"`
	Between *FloatRange `json:"between"`
}

type FloatRange struct {
	Min float64 `json:"min"`
	Max float64 `json:"max"`
}

type Foo struct {
	ID    string `json:"id"`
	Value int    `json:"value"`
}

type FooAggregateResult struct {
	Count    *int     `json:"count"`
	IDMin    *string  `json:"idMin"`
	IDMax    *string  `json:"idMax"`
	ValueMin *int     `json:"valueMin"`
	ValueMax *int     `json:"valueMax"`
	ValueSum *int     `json:"valueSum"`
	ValueAvg *float64 `json:"valueAvg"`
}

type FooFilter struct {
	ID  *StringHashFilter `json:"id"`
	Has *FooHasFilter     `json:"has"`
	And []*FooFilter      `json:"and"`
	Or  []*FooFilter      `json:"or"`
	Not *FooFilter        `json:"not"`
}

type FooOrder struct {
	Asc  *FooOrderable `json:"asc"`
	Desc *FooOrderable `json:"desc"`
	Then *FooOrder     `json:"then"`
}

type FooPatch struct {
	Value *int `json:"value"`
}

type FooRef struct {
	ID    *string `json:"id"`
	Value *int    `json:"value"`
}

type GenerateMutationParams struct {
	Add    *bool `json:"add"`
	Update *bool `json:"update"`
	Delete *bool `json:"delete"`
}

type GenerateQueryParams struct {
	Get       *bool `json:"get"`
	Query     *bool `json:"query"`
	Password  *bool `json:"password"`
	Aggregate *bool `json:"aggregate"`
}

type Int64Filter struct {
	Eq      *string     `json:"eq"`
	Le      *string     `json:"le"`
	Lt      *string     `json:"lt"`
	Ge      *string     `json:"ge"`
	Gt      *string     `json:"gt"`
	Between *Int64Range `json:"between"`
}

type Int64Range struct {
	Min string `json:"min"`
	Max string `json:"max"`
}

type IntFilter struct {
	Eq      *int      `json:"eq"`
	Le      *int      `json:"le"`
	Lt      *int      `json:"lt"`
	Ge      *int      `json:"ge"`
	Gt      *int      `json:"gt"`
	Between *IntRange `json:"between"`
}

type IntRange struct {
	Min int `json:"min"`
	Max int `json:"max"`
}

type IntersectsFilter struct {
	Polygon      *PolygonRef      `json:"polygon"`
	MultiPolygon *MultiPolygonRef `json:"multiPolygon"`
}

type MultiPolygon struct {
	Polygons []*Polygon `json:"polygons"`
}

type MultiPolygonRef struct {
	Polygons []*PolygonRef `json:"polygons"`
}

type NearFilter struct {
	Distance   float64   `json:"distance"`
	Coordinate *PointRef `json:"coordinate"`
}

type Point struct {
	Longitude float64 `json:"longitude"`
	Latitude  float64 `json:"latitude"`
}

type PointGeoFilter struct {
	Near   *NearFilter   `json:"near"`
	Within *WithinFilter `json:"within"`
}

type PointList struct {
	Points []*Point `json:"points"`
}

type PointListRef struct {
	Points []*PointRef `json:"points"`
}

type PointRef struct {
	Longitude float64 `json:"longitude"`
	Latitude  float64 `json:"latitude"`
}

type Polygon struct {
	Coordinates []*PointList `json:"coordinates"`
}

type PolygonGeoFilter struct {
	Near       *NearFilter       `json:"near"`
	Within     *WithinFilter     `json:"within"`
	Contains   *ContainsFilter   `json:"contains"`
	Intersects *IntersectsFilter `json:"intersects"`
}

type PolygonRef struct {
	Coordinates []*PointListRef `json:"coordinates"`
}

type ReadOnlyAggregateResult struct {
	Count          *int    `json:"count"`
	PlaceholderMin *string `json:"_placeholderMin"`
	PlaceholderMax *string `json:"_placeholderMax"`
}

type ReadOnlyFilter struct {
	Has *ReadOnlyHasFilter `json:"has"`
	And []*ReadOnlyFilter  `json:"and"`
	Or  []*ReadOnlyFilter  `json:"or"`
	Not *ReadOnlyFilter    `json:"not"`
}

type ReadOnlyOrder struct {
	Asc  *ReadOnlyOrderable `json:"asc"`
	Desc *ReadOnlyOrderable `json:"desc"`
	Then *ReadOnlyOrder     `json:"then"`
}

type ReadOnlyPatch struct {
	Placeholder *string `json:"_placeholder"`
}

type Stake struct {
	Placeholder            *string  `json:"_placeholder"`
	ID                     string   `json:"id"`
	Token                  *Token   `json:"token"`
	Amount                 float64  `json:"amount"`
	CommittedStakingPeriod int      `json:"committedStakingPeriod"`
	Owner                  *Account `json:"owner"`
}

func (Stake) IsCuid()     {}
func (Stake) IsReadOnly() {}

type StakeAggregateResult struct {
	Count                     *int     `json:"count"`
	PlaceholderMin            *string  `json:"_placeholderMin"`
	PlaceholderMax            *string  `json:"_placeholderMax"`
	IDMin                     *string  `json:"idMin"`
	IDMax                     *string  `json:"idMax"`
	AmountMin                 *float64 `json:"amountMin"`
	AmountMax                 *float64 `json:"amountMax"`
	AmountSum                 *float64 `json:"amountSum"`
	AmountAvg                 *float64 `json:"amountAvg"`
	CommittedStakingPeriodMin *int     `json:"committedStakingPeriodMin"`
	CommittedStakingPeriodMax *int     `json:"committedStakingPeriodMax"`
	CommittedStakingPeriodSum *int     `json:"committedStakingPeriodSum"`
	CommittedStakingPeriodAvg *float64 `json:"committedStakingPeriodAvg"`
}

type StakeFilter struct {
	ID  *StringHashFilter `json:"id"`
	Has *StakeHasFilter   `json:"has"`
	And []*StakeFilter    `json:"and"`
	Or  []*StakeFilter    `json:"or"`
	Not *StakeFilter      `json:"not"`
}

type StakeOrder struct {
	Asc  *StakeOrderable `json:"asc"`
	Desc *StakeOrderable `json:"desc"`
	Then *StakeOrder     `json:"then"`
}

type StakePatch struct {
	Placeholder            *string     `json:"_placeholder"`
	Token                  *TokenRef   `json:"token"`
	Amount                 *float64    `json:"amount"`
	CommittedStakingPeriod *int        `json:"committedStakingPeriod"`
	Owner                  *AccountRef `json:"owner"`
}

type StakeRef struct {
	Placeholder            *string     `json:"_placeholder"`
	ID                     *string     `json:"id"`
	Token                  *TokenRef   `json:"token"`
	Amount                 *float64    `json:"amount"`
	CommittedStakingPeriod *int        `json:"committedStakingPeriod"`
	Owner                  *AccountRef `json:"owner"`
}

type StringExactFilter struct {
	Eq      *string      `json:"eq"`
	In      []*string    `json:"in"`
	Le      *string      `json:"le"`
	Lt      *string      `json:"lt"`
	Ge      *string      `json:"ge"`
	Gt      *string      `json:"gt"`
	Between *StringRange `json:"between"`
}

type StringFullTextFilter struct {
	Alloftext *string `json:"alloftext"`
	Anyoftext *string `json:"anyoftext"`
}

type StringHashFilter struct {
	Eq *string   `json:"eq"`
	In []*string `json:"in"`
}

type StringRange struct {
	Min string `json:"min"`
	Max string `json:"max"`
}

type StringRegExpFilter struct {
	Regexp *string `json:"regexp"`
}

type StringTermFilter struct {
	Allofterms *string `json:"allofterms"`
	Anyofterms *string `json:"anyofterms"`
}

type Token struct {
	Placeholder    *string `json:"_placeholder"`
	Ticker         string  `json:"ticker"`
	Name           string  `json:"name"`
	Nav            float64 `json:"nav"`
	BaseMultiplier float64 `json:"baseMultiplier"`
}

func (Token) IsReadOnly() {}

type TokenAggregateResult struct {
	Count             *int     `json:"count"`
	PlaceholderMin    *string  `json:"_placeholderMin"`
	PlaceholderMax    *string  `json:"_placeholderMax"`
	TickerMin         *string  `json:"tickerMin"`
	TickerMax         *string  `json:"tickerMax"`
	NameMin           *string  `json:"nameMin"`
	NameMax           *string  `json:"nameMax"`
	NavMin            *float64 `json:"navMin"`
	NavMax            *float64 `json:"navMax"`
	NavSum            *float64 `json:"navSum"`
	NavAvg            *float64 `json:"navAvg"`
	BaseMultiplierMin *float64 `json:"baseMultiplierMin"`
	BaseMultiplierMax *float64 `json:"baseMultiplierMax"`
	BaseMultiplierSum *float64 `json:"baseMultiplierSum"`
	BaseMultiplierAvg *float64 `json:"baseMultiplierAvg"`
}

type TokenFilter struct {
	Ticker *StringHashFilter `json:"ticker"`
	Has    *TokenHasFilter   `json:"has"`
	And    []*TokenFilter    `json:"and"`
	Or     []*TokenFilter    `json:"or"`
	Not    *TokenFilter      `json:"not"`
}

type TokenOrder struct {
	Asc  *TokenOrderable `json:"asc"`
	Desc *TokenOrderable `json:"desc"`
	Then *TokenOrder     `json:"then"`
}

type TokenPatch struct {
	Placeholder    *string  `json:"_placeholder"`
	Name           *string  `json:"name"`
	Nav            *float64 `json:"nav"`
	BaseMultiplier *float64 `json:"baseMultiplier"`
}

type TokenRef struct {
	Placeholder    *string  `json:"_placeholder"`
	Ticker         *string  `json:"ticker"`
	Name           *string  `json:"name"`
	Nav            *float64 `json:"nav"`
	BaseMultiplier *float64 `json:"baseMultiplier"`
}

type Transaction struct {
	Placeholder       *string `json:"_placeholder"`
	BlockNumber       int     `json:"blockNumber"`
	TimeStamp         string  `json:"timeStamp"`
	Hash              string  `json:"hash"`
	Nonce             int     `json:"nonce"`
	BlockHash         string  `json:"blockHash"`
	From              string  `json:"from"`
	ContractAddress   string  `json:"contractAddress"`
	To                string  `json:"to"`
	Value             string  `json:"value"`
	TokenName         string  `json:"tokenName"`
	TokenSymbol       string  `json:"tokenSymbol"`
	TokenDecimal      int     `json:"tokenDecimal"`
	TransactionIndex  int     `json:"transactionIndex"`
	Gas               int     `json:"gas"`
	GasPrice          string  `json:"gasPrice"`
	GasUsed           int     `json:"gasUsed"`
	CumulativeGasUsed int     `json:"cumulativeGasUsed"`
	Input             string  `json:"input"`
	Confirmations     int     `json:"confirmations"`
}

func (Transaction) IsReadOnly() {}

type TransactionAggregateResult struct {
	Count                *int     `json:"count"`
	PlaceholderMin       *string  `json:"_placeholderMin"`
	PlaceholderMax       *string  `json:"_placeholderMax"`
	BlockNumberMin       *int     `json:"blockNumberMin"`
	BlockNumberMax       *int     `json:"blockNumberMax"`
	BlockNumberSum       *int     `json:"blockNumberSum"`
	BlockNumberAvg       *float64 `json:"blockNumberAvg"`
	TimeStampMin         *string  `json:"timeStampMin"`
	TimeStampMax         *string  `json:"timeStampMax"`
	HashMin              *string  `json:"hashMin"`
	HashMax              *string  `json:"hashMax"`
	NonceMin             *int     `json:"nonceMin"`
	NonceMax             *int     `json:"nonceMax"`
	NonceSum             *int     `json:"nonceSum"`
	NonceAvg             *float64 `json:"nonceAvg"`
	BlockHashMin         *string  `json:"blockHashMin"`
	BlockHashMax         *string  `json:"blockHashMax"`
	FromMin              *string  `json:"fromMin"`
	FromMax              *string  `json:"fromMax"`
	ContractAddressMin   *string  `json:"contractAddressMin"`
	ContractAddressMax   *string  `json:"contractAddressMax"`
	ToMin                *string  `json:"toMin"`
	ToMax                *string  `json:"toMax"`
	ValueMin             *string  `json:"valueMin"`
	ValueMax             *string  `json:"valueMax"`
	TokenNameMin         *string  `json:"tokenNameMin"`
	TokenNameMax         *string  `json:"tokenNameMax"`
	TokenSymbolMin       *string  `json:"tokenSymbolMin"`
	TokenSymbolMax       *string  `json:"tokenSymbolMax"`
	TokenDecimalMin      *int     `json:"tokenDecimalMin"`
	TokenDecimalMax      *int     `json:"tokenDecimalMax"`
	TokenDecimalSum      *int     `json:"tokenDecimalSum"`
	TokenDecimalAvg      *float64 `json:"tokenDecimalAvg"`
	TransactionIndexMin  *int     `json:"transactionIndexMin"`
	TransactionIndexMax  *int     `json:"transactionIndexMax"`
	TransactionIndexSum  *int     `json:"transactionIndexSum"`
	TransactionIndexAvg  *float64 `json:"transactionIndexAvg"`
	GasMin               *int     `json:"gasMin"`
	GasMax               *int     `json:"gasMax"`
	GasSum               *int     `json:"gasSum"`
	GasAvg               *float64 `json:"gasAvg"`
	GasPriceMin          *string  `json:"gasPriceMin"`
	GasPriceMax          *string  `json:"gasPriceMax"`
	GasUsedMin           *int     `json:"gasUsedMin"`
	GasUsedMax           *int     `json:"gasUsedMax"`
	GasUsedSum           *int     `json:"gasUsedSum"`
	GasUsedAvg           *float64 `json:"gasUsedAvg"`
	CumulativeGasUsedMin *int     `json:"cumulativeGasUsedMin"`
	CumulativeGasUsedMax *int     `json:"cumulativeGasUsedMax"`
	CumulativeGasUsedSum *int     `json:"cumulativeGasUsedSum"`
	CumulativeGasUsedAvg *float64 `json:"cumulativeGasUsedAvg"`
	InputMin             *string  `json:"inputMin"`
	InputMax             *string  `json:"inputMax"`
	ConfirmationsMin     *int     `json:"confirmationsMin"`
	ConfirmationsMax     *int     `json:"confirmationsMax"`
	ConfirmationsSum     *int     `json:"confirmationsSum"`
	ConfirmationsAvg     *float64 `json:"confirmationsAvg"`
}

type TransactionFilter struct {
	Hash *StringHashFilter     `json:"hash"`
	Has  *TransactionHasFilter `json:"has"`
	And  []*TransactionFilter  `json:"and"`
	Or   []*TransactionFilter  `json:"or"`
	Not  *TransactionFilter    `json:"not"`
}

type TransactionOrder struct {
	Asc  *TransactionOrderable `json:"asc"`
	Desc *TransactionOrderable `json:"desc"`
	Then *TransactionOrder     `json:"then"`
}

type TransactionPatch struct {
	Placeholder       *string `json:"_placeholder"`
	BlockNumber       *int    `json:"blockNumber"`
	TimeStamp         *string `json:"timeStamp"`
	Nonce             *int    `json:"nonce"`
	BlockHash         *string `json:"blockHash"`
	From              *string `json:"from"`
	ContractAddress   *string `json:"contractAddress"`
	To                *string `json:"to"`
	Value             *string `json:"value"`
	TokenName         *string `json:"tokenName"`
	TokenSymbol       *string `json:"tokenSymbol"`
	TokenDecimal      *int    `json:"tokenDecimal"`
	TransactionIndex  *int    `json:"transactionIndex"`
	Gas               *int    `json:"gas"`
	GasPrice          *string `json:"gasPrice"`
	GasUsed           *int    `json:"gasUsed"`
	CumulativeGasUsed *int    `json:"cumulativeGasUsed"`
	Input             *string `json:"input"`
	Confirmations     *int    `json:"confirmations"`
}

type TransactionRef struct {
	Placeholder       *string `json:"_placeholder"`
	BlockNumber       *int    `json:"blockNumber"`
	TimeStamp         *string `json:"timeStamp"`
	Hash              *string `json:"hash"`
	Nonce             *int    `json:"nonce"`
	BlockHash         *string `json:"blockHash"`
	From              *string `json:"from"`
	ContractAddress   *string `json:"contractAddress"`
	To                *string `json:"to"`
	Value             *string `json:"value"`
	TokenName         *string `json:"tokenName"`
	TokenSymbol       *string `json:"tokenSymbol"`
	TokenDecimal      *int    `json:"tokenDecimal"`
	TransactionIndex  *int    `json:"transactionIndex"`
	Gas               *int    `json:"gas"`
	GasPrice          *string `json:"gasPrice"`
	GasUsed           *int    `json:"gasUsed"`
	CumulativeGasUsed *int    `json:"cumulativeGasUsed"`
	Input             *string `json:"input"`
	Confirmations     *int    `json:"confirmations"`
}

type UpdateAccountInput struct {
	Filter *AccountFilter `json:"filter"`
	Set    *AccountPatch  `json:"set"`
	Remove *AccountPatch  `json:"remove"`
}

type UpdateAccountPayload struct {
	Account []*Account `json:"account"`
	NumUids *int       `json:"numUids"`
}

type UpdateAppStateInput struct {
	Filter *AppStateFilter `json:"filter"`
	Set    *AppStatePatch  `json:"set"`
	Remove *AppStatePatch  `json:"remove"`
}

type UpdateAppStatePayload struct {
	AppState []*AppState `json:"appState"`
	NumUids  *int        `json:"numUids"`
}

type UpdateBalanceInput struct {
	Filter *BalanceFilter `json:"filter"`
	Set    *BalancePatch  `json:"set"`
	Remove *BalancePatch  `json:"remove"`
}

type UpdateBalancePayload struct {
	Balance []*Balance `json:"balance"`
	NumUids *int       `json:"numUids"`
}

type UpdateFooInput struct {
	Filter *FooFilter `json:"filter"`
	Set    *FooPatch  `json:"set"`
	Remove *FooPatch  `json:"remove"`
}

type UpdateFooPayload struct {
	Foo     []*Foo `json:"foo"`
	NumUids *int   `json:"numUids"`
}

type UpdateReadOnlyInput struct {
	Filter *ReadOnlyFilter `json:"filter"`
	Set    *ReadOnlyPatch  `json:"set"`
	Remove *ReadOnlyPatch  `json:"remove"`
}

type UpdateReadOnlyPayload struct {
	ReadOnly []ReadOnly `json:"readOnly"`
	NumUids  *int       `json:"numUids"`
}

type UpdateStakeInput struct {
	Filter *StakeFilter `json:"filter"`
	Set    *StakePatch  `json:"set"`
	Remove *StakePatch  `json:"remove"`
}

type UpdateStakePayload struct {
	Stake   []*Stake `json:"stake"`
	NumUids *int     `json:"numUids"`
}

type UpdateTokenInput struct {
	Filter *TokenFilter `json:"filter"`
	Set    *TokenPatch  `json:"set"`
	Remove *TokenPatch  `json:"remove"`
}

type UpdateTokenPayload struct {
	Token   []*Token `json:"token"`
	NumUids *int     `json:"numUids"`
}

type UpdateTransactionInput struct {
	Filter *TransactionFilter `json:"filter"`
	Set    *TransactionPatch  `json:"set"`
	Remove *TransactionPatch  `json:"remove"`
}

type UpdateTransactionPayload struct {
	Transaction []*Transaction `json:"transaction"`
	NumUids     *int           `json:"numUids"`
}

type WithinFilter struct {
	Polygon *PolygonRef `json:"polygon"`
}

type AccountHasFilter string

const (
	AccountHasFilterPlaceholder AccountHasFilter = "_placeholder"
	AccountHasFilterAddress     AccountHasFilter = "address"
	AccountHasFilterType        AccountHasFilter = "type"
	AccountHasFilterStakes      AccountHasFilter = "stakes"
	AccountHasFilterBalances    AccountHasFilter = "balances"
)

var AllAccountHasFilter = []AccountHasFilter{
	AccountHasFilterPlaceholder,
	AccountHasFilterAddress,
	AccountHasFilterType,
	AccountHasFilterStakes,
	AccountHasFilterBalances,
}

func (e AccountHasFilter) IsValid() bool {
	switch e {
	case AccountHasFilterPlaceholder, AccountHasFilterAddress, AccountHasFilterType, AccountHasFilterStakes, AccountHasFilterBalances:
		return true
	}
	return false
}

func (e AccountHasFilter) String() string {
	return string(e)
}

func (e *AccountHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountHasFilter", str)
	}
	return nil
}

func (e AccountHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AccountOrderable string

const (
	AccountOrderablePlaceholder AccountOrderable = "_placeholder"
	AccountOrderableAddress     AccountOrderable = "address"
)

var AllAccountOrderable = []AccountOrderable{
	AccountOrderablePlaceholder,
	AccountOrderableAddress,
}

func (e AccountOrderable) IsValid() bool {
	switch e {
	case AccountOrderablePlaceholder, AccountOrderableAddress:
		return true
	}
	return false
}

func (e AccountOrderable) String() string {
	return string(e)
}

func (e *AccountOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountOrderable", str)
	}
	return nil
}

func (e AccountOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AccountType string

const (
	AccountTypeUser             AccountType = "User"
	AccountTypeStakingContract  AccountType = "StakingContract"
	AccountTypeTreasuryContract AccountType = "TreasuryContract"
)

var AllAccountType = []AccountType{
	AccountTypeUser,
	AccountTypeStakingContract,
	AccountTypeTreasuryContract,
}

func (e AccountType) IsValid() bool {
	switch e {
	case AccountTypeUser, AccountTypeStakingContract, AccountTypeTreasuryContract:
		return true
	}
	return false
}

func (e AccountType) String() string {
	return string(e)
}

func (e *AccountType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountType", str)
	}
	return nil
}

func (e AccountType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AppStateHasFilter string

const (
	AppStateHasFilterPlaceholder        AppStateHasFilter = "_placeholder"
	AppStateHasFilterID                 AppStateHasFilter = "id"
	AppStateHasFilterTransactionIds     AppStateHasFilter = "transactionIds"
	AppStateHasFilterTotalStakingPower  AppStateHasFilter = "totalStakingPower"
	AppStateHasFilterMedianStakingPower AppStateHasFilter = "medianStakingPower"
	AppStateHasFilterMaxStakingPower    AppStateHasFilter = "maxStakingPower"
	AppStateHasFilterEthPrice           AppStateHasFilter = "ethPrice"
)

var AllAppStateHasFilter = []AppStateHasFilter{
	AppStateHasFilterPlaceholder,
	AppStateHasFilterID,
	AppStateHasFilterTransactionIds,
	AppStateHasFilterTotalStakingPower,
	AppStateHasFilterMedianStakingPower,
	AppStateHasFilterMaxStakingPower,
	AppStateHasFilterEthPrice,
}

func (e AppStateHasFilter) IsValid() bool {
	switch e {
	case AppStateHasFilterPlaceholder, AppStateHasFilterID, AppStateHasFilterTransactionIds, AppStateHasFilterTotalStakingPower, AppStateHasFilterMedianStakingPower, AppStateHasFilterMaxStakingPower, AppStateHasFilterEthPrice:
		return true
	}
	return false
}

func (e AppStateHasFilter) String() string {
	return string(e)
}

func (e *AppStateHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppStateHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppStateHasFilter", str)
	}
	return nil
}

func (e AppStateHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AppStateOrderable string

const (
	AppStateOrderablePlaceholder        AppStateOrderable = "_placeholder"
	AppStateOrderableID                 AppStateOrderable = "id"
	AppStateOrderableTotalStakingPower  AppStateOrderable = "totalStakingPower"
	AppStateOrderableMedianStakingPower AppStateOrderable = "medianStakingPower"
	AppStateOrderableMaxStakingPower    AppStateOrderable = "maxStakingPower"
	AppStateOrderableEthPrice           AppStateOrderable = "ethPrice"
)

var AllAppStateOrderable = []AppStateOrderable{
	AppStateOrderablePlaceholder,
	AppStateOrderableID,
	AppStateOrderableTotalStakingPower,
	AppStateOrderableMedianStakingPower,
	AppStateOrderableMaxStakingPower,
	AppStateOrderableEthPrice,
}

func (e AppStateOrderable) IsValid() bool {
	switch e {
	case AppStateOrderablePlaceholder, AppStateOrderableID, AppStateOrderableTotalStakingPower, AppStateOrderableMedianStakingPower, AppStateOrderableMaxStakingPower, AppStateOrderableEthPrice:
		return true
	}
	return false
}

func (e AppStateOrderable) String() string {
	return string(e)
}

func (e *AppStateOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppStateOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppStateOrderable", str)
	}
	return nil
}

func (e AppStateOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BalanceHasFilter string

const (
	BalanceHasFilterPlaceholder BalanceHasFilter = "_placeholder"
	BalanceHasFilterID          BalanceHasFilter = "id"
	BalanceHasFilterToken       BalanceHasFilter = "token"
	BalanceHasFilterAmount      BalanceHasFilter = "amount"
	BalanceHasFilterOwner       BalanceHasFilter = "owner"
)

var AllBalanceHasFilter = []BalanceHasFilter{
	BalanceHasFilterPlaceholder,
	BalanceHasFilterID,
	BalanceHasFilterToken,
	BalanceHasFilterAmount,
	BalanceHasFilterOwner,
}

func (e BalanceHasFilter) IsValid() bool {
	switch e {
	case BalanceHasFilterPlaceholder, BalanceHasFilterID, BalanceHasFilterToken, BalanceHasFilterAmount, BalanceHasFilterOwner:
		return true
	}
	return false
}

func (e BalanceHasFilter) String() string {
	return string(e)
}

func (e *BalanceHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BalanceHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BalanceHasFilter", str)
	}
	return nil
}

func (e BalanceHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BalanceOrderable string

const (
	BalanceOrderablePlaceholder BalanceOrderable = "_placeholder"
	BalanceOrderableID          BalanceOrderable = "id"
	BalanceOrderableAmount      BalanceOrderable = "amount"
)

var AllBalanceOrderable = []BalanceOrderable{
	BalanceOrderablePlaceholder,
	BalanceOrderableID,
	BalanceOrderableAmount,
}

func (e BalanceOrderable) IsValid() bool {
	switch e {
	case BalanceOrderablePlaceholder, BalanceOrderableID, BalanceOrderableAmount:
		return true
	}
	return false
}

func (e BalanceOrderable) String() string {
	return string(e)
}

func (e *BalanceOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BalanceOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BalanceOrderable", str)
	}
	return nil
}

func (e BalanceOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CuidHasFilter string

const (
	CuidHasFilterID CuidHasFilter = "id"
)

var AllCuidHasFilter = []CuidHasFilter{
	CuidHasFilterID,
}

func (e CuidHasFilter) IsValid() bool {
	switch e {
	case CuidHasFilterID:
		return true
	}
	return false
}

func (e CuidHasFilter) String() string {
	return string(e)
}

func (e *CuidHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CuidHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CuidHasFilter", str)
	}
	return nil
}

func (e CuidHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CuidOrderable string

const (
	CuidOrderableID CuidOrderable = "id"
)

var AllCuidOrderable = []CuidOrderable{
	CuidOrderableID,
}

func (e CuidOrderable) IsValid() bool {
	switch e {
	case CuidOrderableID:
		return true
	}
	return false
}

func (e CuidOrderable) String() string {
	return string(e)
}

func (e *CuidOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CuidOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CuidOrderable", str)
	}
	return nil
}

func (e CuidOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DgraphIndex string

const (
	DgraphIndexInt      DgraphIndex = "int"
	DgraphIndexInt64    DgraphIndex = "int64"
	DgraphIndexFloat    DgraphIndex = "float"
	DgraphIndexBool     DgraphIndex = "bool"
	DgraphIndexHash     DgraphIndex = "hash"
	DgraphIndexExact    DgraphIndex = "exact"
	DgraphIndexTerm     DgraphIndex = "term"
	DgraphIndexFulltext DgraphIndex = "fulltext"
	DgraphIndexTrigram  DgraphIndex = "trigram"
	DgraphIndexRegexp   DgraphIndex = "regexp"
	DgraphIndexYear     DgraphIndex = "year"
	DgraphIndexMonth    DgraphIndex = "month"
	DgraphIndexDay      DgraphIndex = "day"
	DgraphIndexHour     DgraphIndex = "hour"
	DgraphIndexGeo      DgraphIndex = "geo"
)

var AllDgraphIndex = []DgraphIndex{
	DgraphIndexInt,
	DgraphIndexInt64,
	DgraphIndexFloat,
	DgraphIndexBool,
	DgraphIndexHash,
	DgraphIndexExact,
	DgraphIndexTerm,
	DgraphIndexFulltext,
	DgraphIndexTrigram,
	DgraphIndexRegexp,
	DgraphIndexYear,
	DgraphIndexMonth,
	DgraphIndexDay,
	DgraphIndexHour,
	DgraphIndexGeo,
}

func (e DgraphIndex) IsValid() bool {
	switch e {
	case DgraphIndexInt, DgraphIndexInt64, DgraphIndexFloat, DgraphIndexBool, DgraphIndexHash, DgraphIndexExact, DgraphIndexTerm, DgraphIndexFulltext, DgraphIndexTrigram, DgraphIndexRegexp, DgraphIndexYear, DgraphIndexMonth, DgraphIndexDay, DgraphIndexHour, DgraphIndexGeo:
		return true
	}
	return false
}

func (e DgraphIndex) String() string {
	return string(e)
}

func (e *DgraphIndex) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DgraphIndex(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DgraphIndex", str)
	}
	return nil
}

func (e DgraphIndex) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FooHasFilter string

const (
	FooHasFilterID    FooHasFilter = "id"
	FooHasFilterValue FooHasFilter = "value"
)

var AllFooHasFilter = []FooHasFilter{
	FooHasFilterID,
	FooHasFilterValue,
}

func (e FooHasFilter) IsValid() bool {
	switch e {
	case FooHasFilterID, FooHasFilterValue:
		return true
	}
	return false
}

func (e FooHasFilter) String() string {
	return string(e)
}

func (e *FooHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FooHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FooHasFilter", str)
	}
	return nil
}

func (e FooHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FooOrderable string

const (
	FooOrderableID    FooOrderable = "id"
	FooOrderableValue FooOrderable = "value"
)

var AllFooOrderable = []FooOrderable{
	FooOrderableID,
	FooOrderableValue,
}

func (e FooOrderable) IsValid() bool {
	switch e {
	case FooOrderableID, FooOrderableValue:
		return true
	}
	return false
}

func (e FooOrderable) String() string {
	return string(e)
}

func (e *FooOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FooOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FooOrderable", str)
	}
	return nil
}

func (e FooOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HTTPMethod string

const (
	HTTPMethodGet    HTTPMethod = "GET"
	HTTPMethodPost   HTTPMethod = "POST"
	HTTPMethodPut    HTTPMethod = "PUT"
	HTTPMethodPatch  HTTPMethod = "PATCH"
	HTTPMethodDelete HTTPMethod = "DELETE"
)

var AllHTTPMethod = []HTTPMethod{
	HTTPMethodGet,
	HTTPMethodPost,
	HTTPMethodPut,
	HTTPMethodPatch,
	HTTPMethodDelete,
}

func (e HTTPMethod) IsValid() bool {
	switch e {
	case HTTPMethodGet, HTTPMethodPost, HTTPMethodPut, HTTPMethodPatch, HTTPMethodDelete:
		return true
	}
	return false
}

func (e HTTPMethod) String() string {
	return string(e)
}

func (e *HTTPMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HTTPMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HTTPMethod", str)
	}
	return nil
}

func (e HTTPMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Mode string

const (
	ModeBatch  Mode = "BATCH"
	ModeSingle Mode = "SINGLE"
)

var AllMode = []Mode{
	ModeBatch,
	ModeSingle,
}

func (e Mode) IsValid() bool {
	switch e {
	case ModeBatch, ModeSingle:
		return true
	}
	return false
}

func (e Mode) String() string {
	return string(e)
}

func (e *Mode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Mode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Mode", str)
	}
	return nil
}

func (e Mode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ReadOnlyHasFilter string

const (
	ReadOnlyHasFilterPlaceholder ReadOnlyHasFilter = "_placeholder"
)

var AllReadOnlyHasFilter = []ReadOnlyHasFilter{
	ReadOnlyHasFilterPlaceholder,
}

func (e ReadOnlyHasFilter) IsValid() bool {
	switch e {
	case ReadOnlyHasFilterPlaceholder:
		return true
	}
	return false
}

func (e ReadOnlyHasFilter) String() string {
	return string(e)
}

func (e *ReadOnlyHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReadOnlyHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReadOnlyHasFilter", str)
	}
	return nil
}

func (e ReadOnlyHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ReadOnlyOrderable string

const (
	ReadOnlyOrderablePlaceholder ReadOnlyOrderable = "_placeholder"
)

var AllReadOnlyOrderable = []ReadOnlyOrderable{
	ReadOnlyOrderablePlaceholder,
}

func (e ReadOnlyOrderable) IsValid() bool {
	switch e {
	case ReadOnlyOrderablePlaceholder:
		return true
	}
	return false
}

func (e ReadOnlyOrderable) String() string {
	return string(e)
}

func (e *ReadOnlyOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReadOnlyOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReadOnlyOrderable", str)
	}
	return nil
}

func (e ReadOnlyOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Role string

const (
	RoleAdmin Role = "ADMIN"
	RoleUser  Role = "USER"
)

var AllRole = []Role{
	RoleAdmin,
	RoleUser,
}

func (e Role) IsValid() bool {
	switch e {
	case RoleAdmin, RoleUser:
		return true
	}
	return false
}

func (e Role) String() string {
	return string(e)
}

func (e *Role) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Role(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Role", str)
	}
	return nil
}

func (e Role) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StakeHasFilter string

const (
	StakeHasFilterPlaceholder            StakeHasFilter = "_placeholder"
	StakeHasFilterID                     StakeHasFilter = "id"
	StakeHasFilterToken                  StakeHasFilter = "token"
	StakeHasFilterAmount                 StakeHasFilter = "amount"
	StakeHasFilterCommittedStakingPeriod StakeHasFilter = "committedStakingPeriod"
	StakeHasFilterOwner                  StakeHasFilter = "owner"
)

var AllStakeHasFilter = []StakeHasFilter{
	StakeHasFilterPlaceholder,
	StakeHasFilterID,
	StakeHasFilterToken,
	StakeHasFilterAmount,
	StakeHasFilterCommittedStakingPeriod,
	StakeHasFilterOwner,
}

func (e StakeHasFilter) IsValid() bool {
	switch e {
	case StakeHasFilterPlaceholder, StakeHasFilterID, StakeHasFilterToken, StakeHasFilterAmount, StakeHasFilterCommittedStakingPeriod, StakeHasFilterOwner:
		return true
	}
	return false
}

func (e StakeHasFilter) String() string {
	return string(e)
}

func (e *StakeHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StakeHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StakeHasFilter", str)
	}
	return nil
}

func (e StakeHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StakeOrderable string

const (
	StakeOrderablePlaceholder            StakeOrderable = "_placeholder"
	StakeOrderableID                     StakeOrderable = "id"
	StakeOrderableAmount                 StakeOrderable = "amount"
	StakeOrderableCommittedStakingPeriod StakeOrderable = "committedStakingPeriod"
)

var AllStakeOrderable = []StakeOrderable{
	StakeOrderablePlaceholder,
	StakeOrderableID,
	StakeOrderableAmount,
	StakeOrderableCommittedStakingPeriod,
}

func (e StakeOrderable) IsValid() bool {
	switch e {
	case StakeOrderablePlaceholder, StakeOrderableID, StakeOrderableAmount, StakeOrderableCommittedStakingPeriod:
		return true
	}
	return false
}

func (e StakeOrderable) String() string {
	return string(e)
}

func (e *StakeOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StakeOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StakeOrderable", str)
	}
	return nil
}

func (e StakeOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TokenHasFilter string

const (
	TokenHasFilterPlaceholder    TokenHasFilter = "_placeholder"
	TokenHasFilterTicker         TokenHasFilter = "ticker"
	TokenHasFilterName           TokenHasFilter = "name"
	TokenHasFilterNav            TokenHasFilter = "nav"
	TokenHasFilterBaseMultiplier TokenHasFilter = "baseMultiplier"
)

var AllTokenHasFilter = []TokenHasFilter{
	TokenHasFilterPlaceholder,
	TokenHasFilterTicker,
	TokenHasFilterName,
	TokenHasFilterNav,
	TokenHasFilterBaseMultiplier,
}

func (e TokenHasFilter) IsValid() bool {
	switch e {
	case TokenHasFilterPlaceholder, TokenHasFilterTicker, TokenHasFilterName, TokenHasFilterNav, TokenHasFilterBaseMultiplier:
		return true
	}
	return false
}

func (e TokenHasFilter) String() string {
	return string(e)
}

func (e *TokenHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TokenHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TokenHasFilter", str)
	}
	return nil
}

func (e TokenHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TokenOrderable string

const (
	TokenOrderablePlaceholder    TokenOrderable = "_placeholder"
	TokenOrderableTicker         TokenOrderable = "ticker"
	TokenOrderableName           TokenOrderable = "name"
	TokenOrderableNav            TokenOrderable = "nav"
	TokenOrderableBaseMultiplier TokenOrderable = "baseMultiplier"
)

var AllTokenOrderable = []TokenOrderable{
	TokenOrderablePlaceholder,
	TokenOrderableTicker,
	TokenOrderableName,
	TokenOrderableNav,
	TokenOrderableBaseMultiplier,
}

func (e TokenOrderable) IsValid() bool {
	switch e {
	case TokenOrderablePlaceholder, TokenOrderableTicker, TokenOrderableName, TokenOrderableNav, TokenOrderableBaseMultiplier:
		return true
	}
	return false
}

func (e TokenOrderable) String() string {
	return string(e)
}

func (e *TokenOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TokenOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TokenOrderable", str)
	}
	return nil
}

func (e TokenOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransactionHasFilter string

const (
	TransactionHasFilterPlaceholder       TransactionHasFilter = "_placeholder"
	TransactionHasFilterBlockNumber       TransactionHasFilter = "blockNumber"
	TransactionHasFilterTimeStamp         TransactionHasFilter = "timeStamp"
	TransactionHasFilterHash              TransactionHasFilter = "hash"
	TransactionHasFilterNonce             TransactionHasFilter = "nonce"
	TransactionHasFilterBlockHash         TransactionHasFilter = "blockHash"
	TransactionHasFilterFrom              TransactionHasFilter = "from"
	TransactionHasFilterContractAddress   TransactionHasFilter = "contractAddress"
	TransactionHasFilterTo                TransactionHasFilter = "to"
	TransactionHasFilterValue             TransactionHasFilter = "value"
	TransactionHasFilterTokenName         TransactionHasFilter = "tokenName"
	TransactionHasFilterTokenSymbol       TransactionHasFilter = "tokenSymbol"
	TransactionHasFilterTokenDecimal      TransactionHasFilter = "tokenDecimal"
	TransactionHasFilterTransactionIndex  TransactionHasFilter = "transactionIndex"
	TransactionHasFilterGas               TransactionHasFilter = "gas"
	TransactionHasFilterGasPrice          TransactionHasFilter = "gasPrice"
	TransactionHasFilterGasUsed           TransactionHasFilter = "gasUsed"
	TransactionHasFilterCumulativeGasUsed TransactionHasFilter = "cumulativeGasUsed"
	TransactionHasFilterInput             TransactionHasFilter = "input"
	TransactionHasFilterConfirmations     TransactionHasFilter = "confirmations"
)

var AllTransactionHasFilter = []TransactionHasFilter{
	TransactionHasFilterPlaceholder,
	TransactionHasFilterBlockNumber,
	TransactionHasFilterTimeStamp,
	TransactionHasFilterHash,
	TransactionHasFilterNonce,
	TransactionHasFilterBlockHash,
	TransactionHasFilterFrom,
	TransactionHasFilterContractAddress,
	TransactionHasFilterTo,
	TransactionHasFilterValue,
	TransactionHasFilterTokenName,
	TransactionHasFilterTokenSymbol,
	TransactionHasFilterTokenDecimal,
	TransactionHasFilterTransactionIndex,
	TransactionHasFilterGas,
	TransactionHasFilterGasPrice,
	TransactionHasFilterGasUsed,
	TransactionHasFilterCumulativeGasUsed,
	TransactionHasFilterInput,
	TransactionHasFilterConfirmations,
}

func (e TransactionHasFilter) IsValid() bool {
	switch e {
	case TransactionHasFilterPlaceholder, TransactionHasFilterBlockNumber, TransactionHasFilterTimeStamp, TransactionHasFilterHash, TransactionHasFilterNonce, TransactionHasFilterBlockHash, TransactionHasFilterFrom, TransactionHasFilterContractAddress, TransactionHasFilterTo, TransactionHasFilterValue, TransactionHasFilterTokenName, TransactionHasFilterTokenSymbol, TransactionHasFilterTokenDecimal, TransactionHasFilterTransactionIndex, TransactionHasFilterGas, TransactionHasFilterGasPrice, TransactionHasFilterGasUsed, TransactionHasFilterCumulativeGasUsed, TransactionHasFilterInput, TransactionHasFilterConfirmations:
		return true
	}
	return false
}

func (e TransactionHasFilter) String() string {
	return string(e)
}

func (e *TransactionHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransactionHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransactionHasFilter", str)
	}
	return nil
}

func (e TransactionHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransactionOrderable string

const (
	TransactionOrderablePlaceholder       TransactionOrderable = "_placeholder"
	TransactionOrderableBlockNumber       TransactionOrderable = "blockNumber"
	TransactionOrderableTimeStamp         TransactionOrderable = "timeStamp"
	TransactionOrderableHash              TransactionOrderable = "hash"
	TransactionOrderableNonce             TransactionOrderable = "nonce"
	TransactionOrderableBlockHash         TransactionOrderable = "blockHash"
	TransactionOrderableFrom              TransactionOrderable = "from"
	TransactionOrderableContractAddress   TransactionOrderable = "contractAddress"
	TransactionOrderableTo                TransactionOrderable = "to"
	TransactionOrderableValue             TransactionOrderable = "value"
	TransactionOrderableTokenName         TransactionOrderable = "tokenName"
	TransactionOrderableTokenSymbol       TransactionOrderable = "tokenSymbol"
	TransactionOrderableTokenDecimal      TransactionOrderable = "tokenDecimal"
	TransactionOrderableTransactionIndex  TransactionOrderable = "transactionIndex"
	TransactionOrderableGas               TransactionOrderable = "gas"
	TransactionOrderableGasPrice          TransactionOrderable = "gasPrice"
	TransactionOrderableGasUsed           TransactionOrderable = "gasUsed"
	TransactionOrderableCumulativeGasUsed TransactionOrderable = "cumulativeGasUsed"
	TransactionOrderableInput             TransactionOrderable = "input"
	TransactionOrderableConfirmations     TransactionOrderable = "confirmations"
)

var AllTransactionOrderable = []TransactionOrderable{
	TransactionOrderablePlaceholder,
	TransactionOrderableBlockNumber,
	TransactionOrderableTimeStamp,
	TransactionOrderableHash,
	TransactionOrderableNonce,
	TransactionOrderableBlockHash,
	TransactionOrderableFrom,
	TransactionOrderableContractAddress,
	TransactionOrderableTo,
	TransactionOrderableValue,
	TransactionOrderableTokenName,
	TransactionOrderableTokenSymbol,
	TransactionOrderableTokenDecimal,
	TransactionOrderableTransactionIndex,
	TransactionOrderableGas,
	TransactionOrderableGasPrice,
	TransactionOrderableGasUsed,
	TransactionOrderableCumulativeGasUsed,
	TransactionOrderableInput,
	TransactionOrderableConfirmations,
}

func (e TransactionOrderable) IsValid() bool {
	switch e {
	case TransactionOrderablePlaceholder, TransactionOrderableBlockNumber, TransactionOrderableTimeStamp, TransactionOrderableHash, TransactionOrderableNonce, TransactionOrderableBlockHash, TransactionOrderableFrom, TransactionOrderableContractAddress, TransactionOrderableTo, TransactionOrderableValue, TransactionOrderableTokenName, TransactionOrderableTokenSymbol, TransactionOrderableTokenDecimal, TransactionOrderableTransactionIndex, TransactionOrderableGas, TransactionOrderableGasPrice, TransactionOrderableGasUsed, TransactionOrderableCumulativeGasUsed, TransactionOrderableInput, TransactionOrderableConfirmations:
		return true
	}
	return false
}

func (e TransactionOrderable) String() string {
	return string(e)
}

func (e *TransactionOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransactionOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransactionOrderable", str)
	}
	return nil
}

func (e TransactionOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
